{
  "Syntax": "void ResourceBarrier(\n  [In] uint NumBarriers,\n  [In][Const][NativeArrayInfo (CountParamIndex = 0)] D3D12_RESOURCE_BARRIER* pBarriers,\n);",
  "HelpLink": "https://docs.microsoft.com/windows/win32/api//d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier",
  "Description": "リソースへの複数のアクセスを同期させる必要があることをドライバーに通知します。",
  "Remarks": "\nバリアの記述には3種類あります。\n\n<ul><li><a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ns-d3d12-d3d12_resource_transition_barrier\">D3D12_RESOURCE_TRANSITION_BARRIER</a> -  Transition barriers  indicate that a set of subresources transition between different usages.  The caller must specify the <i>before</i> and <i>after</i> usages of the subresources.  The D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES flag is used to transition all subresources in a resource at the same time.\n          </li><li><a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ns-d3d12-d3d12_resource_aliasing_barrier\">D3D12_RESOURCE_ALIASING_BARRIER</a> - Aliasing barriers indicate a transition between usages of two different resources which have mappings into the same heap.  The application can specify both the before and the after resource.  Note that one or both resources can be NULL (indicating that any tiled resource could cause aliasing).\n          </li><li><a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ns-d3d12-d3d12_resource_uav_barrier\">D3D12_RESOURCE_UAV_BARRIER</a> - Unordered access view barriers indicate all UAV accesses (read or writes) to a particular resource must complete before any future UAV accesses (read or write) can begin.  The specified resource may be NULL.  It is not necessary to insert a UAV barrier between two draw or dispatch calls which only read a UAV.  Additionally, it is not necessary to insert a UAV barrier between two draw or dispatch calls which write to the same UAV if the application knows that it is safe to execute the UAV accesses in any order.  The resource can be NULL (indicating that any UAV access could require the barrier).\n          </li></ul>\n<b>ID3D12GraphicsCommandList::ResourceBarrier</b>にリソースバリア記述の配列が渡された場合、APIは指定された順序でN回（配列の各要素に1回）呼び出されたように動作します。\nパフォーマンスの最適化のために、トランジションは可能な限り1つのAPIコールにまとめてください。\n\nサブリソースの使用状態については、<a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ne-d3d12-d3d12_resource_states\">D3D12_RESOURCE_STATES</a>列挙および<a href=\"https://docs.microsoft.com/windows/win32/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12\">Using Resource Barriers to Synchronize Resource States in Direct3D 12</a>セクションを参照してください。\n\n<a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-discardresource\">ID3D12GraphicsCommandList::DiscardResource</a>が呼び出されたとき、リソース内のすべてのサブリソースは、レンダーターゲット／デプスステンシルリソースの場合、それぞれRENDER_TARGET状態、DEPTH_WRITE状態でなければならない。\n\n\nバックバッファが提示されるときは、D3D12_RESOURCE_STATE_PRESENT状態である必要があります。PRESENT状態ではないリソースに対して<a href=\"https://docs.microsoft.com/windows/win32/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1\">IDXGISwapChain1::Present1</a>が呼び出された場合、デバッグレイヤーの警告が発せられます。\n\n\nリソース使用ビットは、リードオンリーとリード/ライトの2つのカテゴリーに分類されます。\n\n以下の使用ビットは読み取り専用です。\n\n\n<ul><li>D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER</li><li>D3D12_RESOURCE_STATE_INDEX_BUFFER</li><li>D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE</li><li>D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE</li><li>D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT</li><li>D3D12_RESOURCE_STATE_COPY_SOURCE</li><li>D3D12_RESOURCE_STATE_DEPTH_READ</li></ul>\n以下の使用ビットはリード/ライトです。\n\n<ul><li>D3D12_RESOURCE_STATE_UNORDERED_ACCESS</li><li>D3D12_RESOURCE_STATE_DEPTH_WRITE</li></ul>\n以下の使用ビットは書き込み可能です。\n\n<ul><li>D3D12_RESOURCE_STATE_COPY_DEST</li><li>D3D12_RESOURCE_STATE_RENDER_TARGET</li><li>D3D12_RESOURCE_STATE_STREAM_OUT</li></ul>\n最大で1つの書き込みビットを設定できます。\nいずれかの書き込みビットがセットされた場合、どの読み出しビットもセットできません。\n書き込みビットがセットされていない場合、任意の数の読み出しビットがセットされる可能性があります。\n\n任意の時点で、サブリソースは正確に1つの状態（一連のフラグによって決定される）にあります。アプリケーションは、一連の<b>ResourceBarrier</b>呼び出しを行う際に、その状態が一致するようにしなければなりません。言い換えれば、<b>ResourceBarrier</b>への連続した呼び出しの前と後の状態が一致する必要があります。\n\n\nリソース内のすべてのサブリソースを移行する場合、アプリケーションはサブリソースインデックスをD3D12_RESOURCE_BARRIER_ALL_SUBRESOURCESに設定することで、すべてのサブリソースが変更されることを意味します。\n\nパフォーマンスを向上させるためには、アプリケーションにスプリットバリアを使用する必要があります（下記参照）。\n<a href=\"https://docs.microsoft.com/windows/win32/direct3d12/user-mode-heap-synchronization\">Multi-engine synchronization</a>).また、複数のトランジションを可能な限り1つのコールにまとめてください。\n\n\n<h3><a id=\"Runtime_validation\"></a><a id=\"runtime_validation\"></a><a id=\"RUNTIME_VALIDATION\"></a>Runtime validation</h3>\nランタイムは、バリアタイプの値が<a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ne-d3d12-d3d12_resource_barrier_type\">D3D12_RESOURCE_BARRIER_TYPE</a>列挙の有効なメンバーであることを検証します。\n\n\nまた、ランタイムでは以下のことを確認しています。\n\n\n<ul><li>The resource pointer is non-NULL.</li><li>The subresource index is valid</li><li>The before and after states are supported by the <a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ne-d3d12-d3d12_resource_binding_tier\">D3D12_RESOURCE_BINDING_TIER</a> and <a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ne-d3d12-d3d12_resource_flags\">D3D12_RESOURCE_FLAGS</a> flags of the resource.\n            </li><li>Reserved bits in the state masks are not set.</li><li>The before and after states are different.</li><li>The set of bits in the before and after states are valid.</li><li>If the D3D12_RESOURCE_STATE_RESOLVE_SOURCE bit is set, then the resource sample count must be greater than 1.</li><li>If the D3D12_RESOURCE_STATE_RESOLVE_DEST bit is set, then the resource sample count must be equal to 1.</li></ul>\nエイリアシングバリアのために、ランタイムは、どちらかのリソースポインタがNULLでない場合、それがタイル状のリソースを参照しているかどうかを検証します。\n\nUAVバリアの場合、ランタイムは、リソースが非NULLである場合、リソースにD3D12_RESOURCE_STATE_UNORDERED_ACCESSバインドフラグが設定されているかどうかを検証します。\n\n\nバリデーションに失敗すると、<a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/nf-d3d12-id3d12graphicscommandlist-close\">ID3D12GraphicsCommandList::Close</a>はE_INVALIDARGを返します。\n\n\n<h3><a id=\"Debug_layer\"></a><a id=\"debug_layer\"></a><a id=\"DEBUG_LAYER\"></a>Debug layer</h3>\nデバッグ層は通常、ランタイム検証が失敗した場合にエラーを発行します。\n\n<ul><li>If a  subresource transition in a command list is inconsistent with previous transitions in the same command list. </li><li>If a resource is used without first calling <b>ResourceBarrier</b> to put the resource into the correct state.  </li><li>If a resource is illegally bound for read and write at the same time.</li><li>If the <i>before</i> states passed to the <b>ResourceBarrier</b> do not match the <i>after</i> states of previous calls to <b>ResourceBarrier</b>, including the aliasing case.\n            </li></ul>\nデバッグレイヤーはランタイムルールを検証しようとしますが、デバッグレイヤーのエラーが実際のエラーとなるように保守的に動作し、場合によっては実際のエラーがデバッグレイヤーのエラーを生み出さないこともあります。\n\nデバッグ層では、以下のような場合に警告を発します。\n\n<ul><li>All of the cases where the D3D11 debug layer would issues warnings for <a href=\"https://docs.microsoft.com/windows/win32/api/d3d11_2/nf-d3d11_2-id3d11devicecontext2-tiledresourcebarrier\">ID3D11DeviceContext2::TiledResourceBarrier</a>.\n            </li><li>If a depth buffer is used in a non-read-only mode while the resource has the D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE usage bit set.</li></ul>\n\n",
  "Parameters": {
    "NumBarriers": "型: <b>UINT</b>\n\n提出されたバリアー記述の数。",
    "pBarriers": "型: <b>const <a href=\"https://docs.microsoft.com/windows/win32/api/d3d12/ns-d3d12-d3d12_resource_barrier\">D3D12_RESOURCE_BARRIER</a>*</b>\n\nバリアの説明の配列へのポインタ。"
  },
  "Fields": {}
}